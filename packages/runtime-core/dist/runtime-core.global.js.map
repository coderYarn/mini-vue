{
  "version": 3,
  "sources": ["../src/index.ts", "../../shared/src/index/src/index.ts", "../src/vnode.ts", "../../reactivity/src/effect.ts", "../../reactivity/src/reactive.ts", "../src/component.ts", "../src/patchProps.ts", "../src/render.ts"],
  "sourcesContent": ["export { h,Text,Fragment } from './vnode'\r\nexport { render } from \"./render\"\r\n", "export function isObject(value) {\r\n  return typeof value === 'object' && value !== null;\r\n}\r\n\r\nexport function isFunction(value) {\r\n  return typeof value === 'function';\r\n}\r\n\r\nexport function isArray(value) {\r\n  return Array.isArray(value);\r\n}\r\n\r\nexport function isString(value) {\r\n  return typeof value === 'string';\r\n}\r\n\r\nexport function isNumber(value) {\r\n  return typeof value === 'number';\r\n}\r\n\r\nexport function hasChanged(value, oldValue) {\r\n  return value !== oldValue && (value === value || oldValue === oldValue);\r\n}\r\n\r\nconst camelizeRE = /-(\\w)/g;\r\nexport function camelize(str) {\r\n  return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));\r\n}\r\n\r\nexport function capitalize(str) {\r\n  return str[0].toUpperCase() + str.slice(1);\r\n}", "import { isArray, isFunction, isObject } from '@mini-vue/shared'\r\n\r\nexport const Text = Symbol('text');\r\nexport const Fragment = Symbol('fragment');\r\n\r\nexport const ShapeFlags = {\r\n  ELEMENT: 1,\r\n  TEXT: 1 << 1,\r\n  FRAGMENT: 1 << 2,\r\n  STATEFUL_COMPONENT: 1 << 3,\r\n  FUNCTIONAL_COMPONENT: 1 << 4,\r\n  COMPONENT: (1 << 3) | (1 << 4),\r\n  TEXT_CHILDREN: 1 << 5,\r\n  ARRAY_CHILDREN: 1 << 6,\r\n  CHILDREN: (1 << 5) | (1 << 6)\r\n};\r\n\r\nexport function h(type, props = null, children = null) {\r\n  let shapeFlag = 0;\r\n  \r\n  if (typeof type === 'string') {\r\n    shapeFlag = ShapeFlags.ELEMENT;\r\n  } else if (type === Text) {\r\n    shapeFlag = ShapeFlags.TEXT;\r\n  } else if (type === Fragment) {\r\n  \r\n    \r\n    shapeFlag = ShapeFlags.FRAGMENT;\r\n  } else if (isFunction(type)) {\r\n    shapeFlag = ShapeFlags.FUNCTIONAL_COMPONENT;\r\n  } else {\r\n    shapeFlag = ShapeFlags.STATEFUL_COMPONENT;\r\n  }\r\n\r\n  if (typeof children === 'string' || typeof children === \"number\") {\r\n    shapeFlag |= ShapeFlags.TEXT_CHILDREN;\r\n    children = children.toString()\r\n  } else if (Array.isArray(children)) {\r\n    shapeFlag |= ShapeFlags.ARRAY_CHILDREN;\r\n  }\r\n\r\n  return {\r\n    type,\r\n    props,\r\n    children,\r\n    shapeFlag,\r\n    el:null,\r\n    anchor:null,\r\n    key:props && props.key\r\n  };\r\n}\r\n\r\nexport function normalizeVNode(result){\r\n  if(isArray(result)){\r\n    return h(Fragment,null,result)\r\n  }\r\n  if(isObject(result)){\r\n    return result\r\n  }\r\n  return h(Text,null,result.toString());\r\n}\r\n", "let activeEffect;\r\nlet effectStack = []\r\ninterface effectOptions{\r\n  lazy?:boolean\r\n  scheduler?:()=>void\r\n}\r\nexport function effect(fn,option:effectOptions = {}){\r\n    const effectFn = ()=>{\r\n      try{\r\n        activeEffect = fn\r\n        effectStack.push(activeEffect)\r\n        return fn();\r\n      }finally{\r\n        \r\n        effectStack.pop();\r\n        activeEffect=effectStack[effectStack.length - 1]\r\n      }\r\n    }\r\n    if(!option.lazy){\r\n      effectFn()\r\n    }\r\n    effectFn.scheduler = option.scheduler\r\n    return effectFn;\r\n}\r\n\r\nconst targetMap = new WeakMap()\r\nexport function track(target, key){\r\n  if(!activeEffect){\r\n    return ;\r\n  }\r\n\r\n  let depsMap =targetMap.get(target)\r\n\r\n  if(!depsMap){\r\n    targetMap.set(target,(depsMap = new Map()))\r\n  }\r\n  let deps = depsMap.get(key)\r\n  if(!deps){\r\n    depsMap.set(key, (deps=new Set()))\r\n  }\r\n  deps.add(activeEffect)\r\n}\r\n\r\nexport function trigger(target, key?, newValue?, oldValue?){\r\n  let depsMap =targetMap.get(target)\r\n\r\n  if(!depsMap){\r\n    return \r\n  }\r\n  let deps = depsMap.get(key)\r\n  if(!deps){\r\n    return \r\n  }\r\n  deps.forEach(effect => {\r\n    if(effect.scheduler){\r\n      effect.scheduler(effect)\r\n    }else{\r\n      effect()\r\n    }\r\n  });\r\n}\r\n", "import { isObject,hasChanged,isArray } from '@mini-vue/shared'\r\nimport { track,trigger } from './effect'\r\n\r\nconst proxyMap = new WeakMap()\r\nexport function reactive<T extends Object>(target: T) {\r\n  if (!isObject(target)) {\r\n    return\r\n  }\r\n  if(isReactive(target)){\r\n    return target\r\n  }\r\n  if(proxyMap.has(target)){\r\n    return proxyMap.get(target)\r\n  }\r\n  const proxy = new Proxy(target, {\r\n    get(target: T, key: string | symbol, receiver: T) {\r\n      if(key === \"__isReactive\"){\r\n        return true\r\n      }\r\n      const result = Reflect.get(target, key, receiver)\r\n      track(target,key)\r\n\r\n      return isObject(result)? reactive(result):result\r\n    },\r\n    set(target: T, key: string | symbol, value: any, receiver: T) {\r\n      let oldLength;\r\n      if(isArray(target)){\r\n        oldLength = target.length\r\n      }\r\n      const oldVal = target[key]\r\n      const result = Reflect.set(target, key, value, receiver)\r\n      \r\n      if(hasChanged(oldVal,value)){\r\n        trigger(target,key,value,oldVal)\r\n        if(oldLength == (target as any).length ){\r\n          trigger(target,'length')\r\n        }\r\n\r\n      }\r\n\r\n      return result\r\n    }\r\n  })\r\n  proxyMap.set(target,proxy)\r\n  return proxy\r\n}\r\n\r\nexport function isReactive(targer){\r\n  return !!(targer && targer.__isReactive);\r\n}", "import {reactive} from \"@mini-vue/reactivity\"\r\nimport { normalizeVNode } from \"./vnode\"\r\nfunction initProps(instance,vnode){\r\n  const {type:Component,props:vnodeProps} = vnode\r\n  \r\n  const props = instance.props = {}\r\n  const attrs = instance.attrs = {}\r\n\r\n  \r\n  for (const key in vnodeProps) {\r\n    if(Component.props?.includes(key)){\r\n      props[key] = vnodeProps[key]\r\n    }else{\r\n      attrs[key] = vnodeProps[key]\r\n    }\r\n  }\r\n\r\n  \r\n  instance.props = reactive(instance.props)\r\n}\r\n\r\nexport function mountComponent(vnode,container,anchor,patch){\r\n  const {type:Component} = vnode\r\n\r\n  const instance = {\r\n    props:null,\r\n    attrs:null,\r\n    setupState:null,\r\n    ctx:null,\r\n    mount:null\r\n  }\r\n  initProps(instance,vnode)\r\n  instance.setupState = Component.setup?.(instance.props,{attrs:instance.attrs})\r\n  instance.ctx = {\r\n    ...instance.props,\r\n    ...instance.setupState\r\n  }\r\n  instance.mount = ()=>{\r\n\r\n    const subTree =  normalizeVNode(Component.render(instance.ctx))\r\n    if(Object.keys(instance.attrs).length){\r\n      subTree.props={\r\n        ...subTree.props,\r\n        ...instance.attrs\r\n      }\r\n    }\r\n    patch(null,subTree,container,anchor)\r\n  }\r\n  instance.mount()\r\n}", "const domPropsRE = /[A-Z]|^(value|checked|selected|muted|disabled)$/;\r\nexport function patchProps(el, oldProps, newProps) {\r\n  \r\n  if (oldProps === newProps) {\r\n    return\r\n  }\r\n  oldProps = oldProps || {};\r\n  newProps = newProps || {};\r\n  for (const key in newProps) {\r\n    if(key ==='key'){\r\n      continue\r\n    }\r\n    const next = newProps[key]\r\n    const prev = oldProps[key]\r\n    if (prev !== next) {\r\n      patchDomProp(prev, next, key, el)\r\n    }\r\n    for (const key in oldProps) {\r\n      if(key !== 'key' && newProps[key]==null){\r\n        patchDomProp(oldProps[key],null,key,el)\r\n      }\r\n    }\r\n  }\r\n}\r\nexport function patchDomProp(prev, next, key, el) {\r\n  switch (key) {\r\n    case 'class':      \r\n      el.className = next || '';\r\n      break;\r\n    case 'style':\r\n      if(next == null){\r\n        el.removeAttribute('style')\r\n      }else{\r\n        for (const styleName in next) {\r\n          el.style[styleName] = next[styleName]\r\n        }\r\n        if (prev) {\r\n          for (const styleName in prev) {\r\n            if (next[styleName] == null) {\r\n              el.style[styleName] = ''\r\n            }\r\n          }\r\n        }\r\n      }\r\n      \r\n      break;\r\n    default:\r\n      if (/^on[^a-z]/.test(key)) {\r\n        const eventName = key.slice(2).toLowerCase();\r\n        if(prev){\r\n          el.removeEventListener(eventName,prev)\r\n        }\r\n        if(next){\r\n          el.addEventListener(eventName, next)\r\n        }\r\n      } else if (domPropsRE.test(key)) {\r\n        if (next === '' && typeof el[key] === 'boolean') {\r\n          next = true\r\n        }\r\n        el[key] = next;\r\n      } else {\r\n        if (next == null || next === false) {\r\n          el.removeAttribute(key)\r\n        } {\r\n          el.setAttribute(key, next)\r\n        }\r\n      }\r\n  }\r\n}", "\r\nimport { mountComponent } from \"./component\";\r\nimport { patchProps } from \"./patchProps\";\r\nimport { ShapeFlags } from \"./vnode\";\r\n\r\nexport function render(vnode, container) {\r\n  const prevVNode = container._vnode;\r\n  if (!vnode) {\r\n    if (prevVNode) {\r\n      unmount(prevVNode);\r\n    }\r\n  } else {\r\n    patch(prevVNode, vnode, container);\r\n  }\r\n  container._vnode = vnode;\r\n}\r\n/**\r\n * \r\n * @param n1 \u8001\u8282\u70B9\r\n * @param n2 \u65B0\u8282\u70B9\r\n * @param el \u5BB9\u5668\r\n */\r\nfunction patch(n1, n2, container, anchor?) {\r\n  if (n1 && !isSameVNode(n1, n2)) {\r\n    // n1\u88AB\u5378\u8F7D\u540E\uFF0Cn2\u5C06\u4F1A\u521B\u5EFA\uFF0C\u56E0\u6B64anchor\u81F3\u5173\u91CD\u8981\u3002\u9700\u8981\u5C06\u5B83\u8BBE\u7F6E\u4E3An1\u7684\u4E0B\u4E00\u4E2A\u5144\u5F1F\u8282\u70B9\r\n    anchor = (n1.anchor || n1.el).nextSibling\r\n    unmount(n1);\r\n    n1 = null;\r\n  }\r\n\r\n  const { shapeFlag } = n2;\r\n  if (shapeFlag & ShapeFlags.ELEMENT) {\r\n    processElement(n1, n2, container, anchor);\r\n  } else if (shapeFlag & ShapeFlags.TEXT) {\r\n    processText(n1, n2, container, anchor);\r\n  } else if (shapeFlag & ShapeFlags.FRAGMENT) {\r\n    processFragment(n1, n2, container, anchor);\r\n  } else if (shapeFlag & ShapeFlags.COMPONENT) {\r\n    processComponent(n1, n2, container, anchor);\r\n  }\r\n}\r\n\r\nfunction patchElement(n1, n2) {\r\n  n2.el = n1.el;\r\n  patchProps(n1.props, n2.props, n2.el)\r\n  patchChildren(n1, n2, n2.el)\r\n}\r\n\r\nfunction patchChildren(n1, n2, container, anchor?) {\r\n  const { shapeFlag: prevShapeFlag, children: c1 } = n1;\r\n  const { shapeFlag, children: c2 } = n2;\r\n  if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\r\n    if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n      unmountChildren(c1)\r\n    }\r\n    if (c1 !== c2) {\r\n      container.textContent = c2.textContent;\r\n    }\r\n\r\n  } else if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n    if (prevShapeFlag & ShapeFlags.TEXT_CHILDREN) {\r\n      container.textContent = '';\r\n      mountChildren(c2, container, anchor)\r\n    } else if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n      if (c1[0] && c1[0].key !== null && c2[0] && c2[0].key !== null) {\r\n        patchKeyChildren(c1, c2, container, anchor)\r\n      } else {\r\n        patchUnKeyChildren(c1, c2, container, anchor)\r\n      }\r\n\r\n    } else {\r\n      mountChildren(c2, container, anchor)\r\n    }\r\n  } else {\r\n    if (prevShapeFlag & ShapeFlags.TEXT_CHILDREN) {\r\n      container.textContent = '';\r\n    }\r\n    if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n      unmountChildren(c1)\r\n    }\r\n  }\r\n}\r\nfunction unmount(vnode) {\r\n  const { shapeFlag, el } = vnode\r\n  if (shapeFlag & ShapeFlags.COMPONENT) {\r\n    unmountComponent(vnode)\r\n  } else if (shapeFlag & ShapeFlags.FRAGMENT) {\r\n    unmountFragment(vnode)\r\n  } else {\r\n    el.parentNode.removeChild(el)\r\n  }\r\n}\r\nfunction unmountChildren(children) {\r\n\r\n  children.forEach(child => {\r\n    unmount(child)\r\n  });\r\n}\r\nfunction processText(n1, n2, container, anchor) {\r\n  if (n1) {\r\n    n2.el = n1.el;\r\n    n2.el.textContent = n2.children;\r\n\r\n  } else {\r\n    mountTextNode(n2, container, anchor);\r\n  }\r\n}\r\nfunction processFragment(n1, n2, container, anchor) {\r\n  const fragmentStartAnchor = (n2.el = n1\r\n    ? n1.el\r\n    : document.createTextNode(''));\r\n  const fragmentEndAnchor = (n2.anchor = n1\r\n    ? n1.anchor\r\n    : document.createTextNode(''));\r\n  if (n1) {\r\n    patchChildren(n1, n2, container, fragmentEndAnchor);\r\n  } else {\r\n\r\n    // container.appendChild(fragmentStartAnchor);\r\n    // container.appendChild(fragmentEndAnchor);\r\n    container.insertBefore(fragmentStartAnchor, anchor);\r\n    container.insertBefore(fragmentEndAnchor, anchor);\r\n    mountChildren(n2.children, container, fragmentEndAnchor);\r\n  }\r\n}\r\nfunction processComponent(n1, n2, container, anchor) {\r\n  if(n1){\r\n     // \r\n  }else{\r\n    mountComponent(n2,container,anchor,patch)\r\n  }\r\n}\r\nfunction processElement(n1, n2, container, anchor) {\r\n\r\n  \r\n  if (n1) {\r\n    patchElement(n1, n2)\r\n  } else {\r\n    mountElement(n2, container, anchor)\r\n  }\r\n}\r\n\r\nfunction unmountComponent(vnode) {\r\n\r\n}\r\nfunction unmountFragment(vnode) {\r\n  // unmountChildren(vnode.children)\r\n  // eslint-disable-next-line prefer-const\r\n  let { el: cur, anchor: end } = vnode;\r\n  const { parentNode } = cur;\r\n  while (cur !== end) {\r\n    const next = cur.nextSibling;\r\n    cur.parentNode.removeChild(cur);\r\n    cur = next;\r\n  }\r\n  parentNode.removeChild(end);\r\n\r\n}\r\n\r\nfunction isSameVNode(n1, n2) {\r\n  return n1.type === n2.type\r\n}\r\nfunction mountTextNode(vnode, container, anchor) {\r\n\r\n  const textNode = document.createTextNode(vnode.children);\r\n  container.insertBefore(textNode, anchor);\r\n  vnode.el = textNode;\r\n\r\n}\r\nfunction mountElement(vnode, container, anchor) {\r\n  const { type, props, shapeFlag, children } = vnode;\r\n  const el = document.createElement(type);\r\n\r\n  \r\n  if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\r\n    el.textContent = children;\r\n  } else if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n    // \u8FD9\u91CC\u4E0D\u80FD\u4F20anchor\u3002\u56E0\u4E3Aanchor\u9650\u5236\u7684\u662F\u5F53\u524D\u7684element\r\n    // \u4F5C\u4E3A\u672Celement\u7684children\uFF0C\u4E0D\u7528\u6307\u5B9Aanchor\uFF0Cappend\u5C31\u884C\r\n    mountChildren(children, el, null);\r\n\r\n    \r\n  }\r\n\r\n  if (props) {\r\n    patchProps(el, null, props);\r\n  }\r\n\r\n  vnode.el = el;\r\n  container.insertBefore(el, anchor);\r\n}\r\n\r\nfunction mountChildren(children, container, anchor) {\r\n  children.forEach((child) => {\r\n    patch(null, child, container, anchor);\r\n  });\r\n}\r\n\r\nfunction patchUnKeyChildren(c1, c2, container, anthor) {\r\n  const oldLength = c1.length;\r\n  const newLength = c2.length;\r\n\r\n  const commonLength = Math.min(oldLength, newLength)\r\n  for (let i = 0; i < commonLength; i++) {\r\n    patch(c1[i], c2[i], container, anthor)\r\n\r\n  }\r\n  if (oldLength > newLength) {\r\n    unmountChildren(c1.slice(commonLength))\r\n  } else if (oldLength < newLength) {\r\n    mountChildren(c2.slice(commonLength), container, anthor)\r\n  }\r\n}\r\nfunction patchKeyChildren(c1, c2, container, anthor) {\r\n  let i = 0;\r\n  let e1 = c1.length - 1;\r\n  let e2 = c2.length - 1;\r\n  while (i <= e1 && i <= e2 && c1[i].key === c2[i].key) {\r\n    patch(c1[i], c2[i], container, anthor)\r\n    i++\r\n  }\r\n  while (i <= e1 && i <= e2 && c1[e1].key === c2[e2].key) {\r\n    patch(c1[e1], c2[e2], container, anthor)\r\n    e1--\r\n    e2--\r\n  }\r\n  if (i > e1) {\r\n    for (let j = i; j <= e2; j++) {\r\n      const curAnchor = (c2[e2 + 1] && c2[e2 + 1].el) || anthor;\r\n      patch(null, c2[j], container, curAnchor)\r\n    }\r\n  } else if (i > e2) {\r\n    for (let j = i; j < e1; j++) {\r\n      unmount(c1[j])\r\n    }\r\n  } else {\r\n    const map = new Map()\r\n    for (let j = i; j <=e1; j++) {\r\n      const prev = c1[j]\r\n      map.set(prev.key, prev)\r\n    }\r\n    let maxNewIndexSoFar = 0;\r\n    let source = new Array(e2 - i + 1).fill(-1)\r\n    let move = false\r\n    const toMounted = []\r\n    for (let k = 0; k < c2.length; k++) {\r\n      const next = c2[k];\r\n\r\n      if (map.has(next.key)) {\r\n        const { prev, j } = map.get(next.key)\r\n        patch(prev, next, container, anthor)\r\n        if (j < maxNewIndexSoFar) {\r\n          move = true\r\n        } else {\r\n          maxNewIndexSoFar = j\r\n        }\r\n        source[k] = j;\r\n        map.delete(next.key)\r\n      } else {\r\n        toMounted.push(k + i)\r\n      }\r\n    }\r\n    map.forEach(({ prev }) => {\r\n      unmount(prev)\r\n    })\r\n    if (move) {\r\n      const seq = getSequence(source)\r\n      let j = seq.length - 1;\r\n      for (let k = source.length - 1; k >= 0; k--) {\r\n        if (seq[j] === k) {\r\n          j--\r\n        } else {\r\n          const pos = k + i;\r\n          const nextPos = pos + 1;\r\n          const curAnchor = (c2[nextPos] && c2[nextPos].el) || anthor\r\n          if (source[k] === -1) {\r\n            patch(null, c2[pos], container, curAnchor)\r\n          } else {\r\n            container.insertBefore(c2[pos].el, curAnchor)\r\n          }\r\n        }\r\n      }\r\n    } else if (toMounted.length) {\r\n      for (let k = toMounted.length - 1; k >= 0; k--) {\r\n        const pos = toMounted[k];\r\n        const nextPos = pos + 1;\r\n        const curAnchor = (c2[nextPos] && c2[nextPos].el) || anthor\r\n        patch(null, c2[pos], container, curAnchor)\r\n\r\n      }\r\n    }\r\n  }\r\n}\r\nfunction getSequence(nums) {\r\n  const result = [];\r\n  const position = [];\r\n  for (let i = 0; i < nums.length; i++) {\r\n    if (nums[i] === -1) {\r\n      continue;\r\n    }\r\n    // result[result.length - 1]\u53EF\u80FD\u4E3Aundefined\uFF0C\u6B64\u65F6nums[i] > undefined\u4E3Afalse\r\n    if (nums[i] > result[result.length - 1]) {\r\n      result.push(nums[i]);\r\n      position.push(result.length - 1);\r\n    } else {\r\n      let l = 0,\r\n        r = result.length - 1;\r\n      while (l <= r) {\r\n        const mid = ~~((l + r) / 2);\r\n        if (nums[i] > result[mid]) {\r\n          l = mid + 1;\r\n        } else if (nums[i] < result[mid]) {\r\n          r = mid - 1;\r\n        } else {\r\n          l = mid;\r\n          break;\r\n        }\r\n      }\r\n      result[l] = nums[i];\r\n      position.push(l);\r\n    }\r\n  }\r\n  let cur = result.length - 1;\r\n  // \u8FD9\u91CC\u590D\u7528\u4E86result\uFF0C\u5B83\u672C\u8EAB\u5DF2\u7ECF\u6CA1\u7528\u4E86\r\n  for (let i = position.length - 1; i >= 0 && cur >= 0; i--) {\r\n    if (position[i] === cur) {\r\n      result[cur--] = i;\r\n    }\r\n  }\r\n  return result;\r\n}\r\nfunction patchKeyChildren2(c1, c2, container, anthor) {\r\n  const map = new Map()\r\n  c1.forEach((prev, j) => {\r\n    map.set(prev.key, prev)\r\n  });\r\n  let maxNewIndexSoFar = 0;\r\n  for (let i = 0; i < c2.length; i++) {\r\n    const next = c2[i];\r\n    const curAnchor = i === 0 ? c1[0].el : c2[i - 1].el.nextSibling\r\n    if (map.has(next.key)) {\r\n      const { prev, j } = map.get(next.key)\r\n      patch(prev, next, container, anthor)\r\n      if (j < maxNewIndexSoFar) {\r\n        container.insertBefore(next.el, curAnchor)\r\n      } else {\r\n        maxNewIndexSoFar = j\r\n      }\r\n    } else {\r\n\r\n      patch(null, next, container, curAnchor)\r\n    }\r\n  }\r\n  map.forEach(({ prev }) => {\r\n    unmount(prev)\r\n  })\r\n\r\n}"],
  "mappings": "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",
  "names": []
}
